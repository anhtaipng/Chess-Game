import {createAsyncThunk, createSlice} from "@reduxjs/toolkit";
import {fetchElo, fetchUser, login, register} from "./userAPI";

export const UserConstant = {
    // user login status
    LOGGING_IN: "LOGGING",
    NOT_LOGGED_IN: "NOT_LOGGED_IN",
    LOGGING_IN_LOADING: "LOGIN_LOADING",
    LOGGED_IN: "LOGGED_IN",
    LOGGED_IN_FAILED: "LOGIN_FAIL",
    REGISTERING: "REGGING",
    REGISTERING_LOADING: "REG_LOAD",
    REGISTERING_FAILED:"REG_FAILED",
    REGISTERING_SUCCESS: "REG_SUCCESS",
    // User online stastus
    STATUS_ONLINE: "online",
    STATUS_OFFLINE: "offline",
    STATUS_PLAYING: "playing",
    // User refetch status
    STATE_FETCHING: "pending",
    STATE_LOADED: "loaded",
    // User ranking
    RANKING_NOVICE: "novice",
    RANKING_CLASS_D: "D",
    RANKING_CLASS_C: "C",
    RANKING_CLASS_B: "B",
    RANKING_CLASS_A: "A",
    RANKING_CM: "CM",
    RANKING_FM: "FM",
    RANKING_IM: "IM",
    RANKING_GM: "GM",
    RANKING_WORLD_CONTENDER: "WORLD_CLASS",
    RANKING_CANDIDATE_MASTER: "Master Candidate",
}

const initialState = {
    login_status: UserConstant.NOT_LOGGED_IN,
    state: UserConstant.STATE_FETCHING,
    id_user: "Guest",
    status: UserConstant.STATUS_OFFLINE,
    displayName: "Guest",
    ranking: UserConstant.RANKING_NOVICE,
    elo: 1200,
    money: 0,
    user_token: ""
};

export let userToken = "";
// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests    .
export const fetchAndUpdateElo = createAsyncThunk("user/fetchElo", async () => {
    const response = await fetchElo();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
});
export const fetchAndUpdateUser = createAsyncThunk(
    "user/fetchUser",
    async (userID) => {
        const response = await fetchUser(userID);
        // The value we return becomes the `fulfilled` action payload
        return response.data;
    }
);
// try {
//     const response = await userAPI.updateById(id, fields)
//     return response.data.user
// } catch (err) {
//     // Use `err.response.data` as `action.payload` for a `rejected` action,
//     // by explicitly returning it using the `rejectWithValue()` utility
//     return rejectWithValue(err.response.data)
// }
export const loginUser = createAsyncThunk(
    "user/loginUser",
    async (userInfo,{ rejectWithValue } ) =>{
        try{
            const response = await login(userInfo);
            return response.data;
        } catch (error) {
            return rejectWithValue({ error: error.message });
        }
    }
)
export const registerUser = createAsyncThunk(
    "user/registerUser",
    async(userInfo,{ rejectWithValue }) => {
        try{
            const response = await register(userInfo);
            console.log("INSDIE REG THUNK:", response);
            return response.data;
        }
        catch (err){
            return rejectWithValue(err);
        }
    }
)

export const userSlice = createSlice({
    name: "user",
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        updateDisplayName: (state, action) => {
            state.displayName = action.payload.newDisplayName;
        },
        // Use the PayloadAction type to declare the contents of `action.payload`
        increaseElo: (state, action) => {
            state.elo += action.payload.eloGain;
        },
        decreaseElo: (state, action) => {
            state.elo -= action.payload.eloLoss;
        },
        setElo: (state, action) => {
            state.elo = action.payload.newElo;
        },
        userLogged: (state) => {
            state.login_status = UserConstant.LOGGED_IN;
        },
        userLoggingIn: (state,action)=>{
            state.login_status = UserConstant.LOGGING_IN;
        },
        userRegistering: (state,action)=>{
            state.login_status = UserConstant.REGISTERING;
        }
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(fetchAndUpdateElo.pending, (state) => {
                state.elo = "updating elo point";
            })
            .addCase(fetchAndUpdateElo.fulfilled, (state, action) => {
                // * Please remember to add new ranking based on the player elo
                let newElo = action.payload.elo;
                state.elo = newElo;
                if (newElo <= 1200) {
                    state.ranking = UserConstant.RANKING_NOVICE;
                } else if (newElo <= 1400) {
                    state.ranking = UserConstant.RANKING_CLASS_D;
                } else if (newElo <= 1600) {
                    state.ranking = UserConstant.RANKING_CLASS_C;
                } else if (newElo <= 1800) {
                    state.ranking = UserConstant.RANKING_CLASS_B;
                } else if (newElo <= 2000) {
                    state.ranking = UserConstant.RANKING_CLASS_A;
                } else if (newElo <= 2200) {
                    state.ranking = UserConstant.RANKING_CANDIDATE_MASTER;
                } else if (newElo <= 2300) {
                    state.ranking = UserConstant.RANKING_CM;
                } else if (newElo <= 2400) {
                    state.ranking = UserConstant.RANKING_FM;
                } else if (newElo <= 2500) {
                    state.ranking = UserConstant.RANKING_IM;
                } else if (newElo <= 2700) {
                    state.ranking = UserConstant.RANKING_GM;
                }
                else {
                    state.ranking = UserConstant.RANKING_WORLD_CONTENDER;
                }
            })
            .addCase(fetchAndUpdateUser.pending, (state) => {
                state.status = UserConstant.STATE_FETCHING;
            })
            .addCase(fetchAndUpdateUser.fulfilled, (state, action) => {
                state = action.payload;
            })
            .addCase(loginUser.pending,(state)=>{
                state.login_status = UserConstant.LOGGING_IN_LOADING;
            })
            .addCase(loginUser.fulfilled,(state,action)=>{
                state.login_status = UserConstant.LOGGED_IN;
                // let newUser = action.payload;
                // state = {...state, ...newUser};
                console.log("login fullfill:", action);
                console.log("login_token:",action.payload.token)
                state.user_token = action.payload.token;
                userToken = action.payload.token;
            })
            .addCase(loginUser.rejected,(state,action)=>{
                state.login_status = UserConstant.LOGGED_IN_FAILED;
            })
            .addCase(registerUser.pending,(state)=>{
                state.login_status = UserConstant.REGISTERING;
            })
            .addCase(registerUser.fulfilled,(state,action)=>{
                state.login_status = UserConstant.REGISTERING_SUCCESS;
                console.log(action);
                let newUser = action.payload;
                state = {...state, ...newUser};
            })
            .addCase(registerUser.rejected,(state,action)=>{
                state.login_status = UserConstant.REGISTERING_FAILED;
            })
            ;

    },
});

export const {updateDisplayName,userRegistering,userLoggingIn} =
    userSlice.actions;

export default userSlice.reducer;

// // The function below is called a selector and allows us to select a value from
// // the state. Selectors can also be defined inline where they're used instead of
// // in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
// export const selectCount = (state) => state.counter.value;

// // We can also write thunks by hand, which may contain both sync and async logic.
// // Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd = (amount) => (dispatch, getState) => {
//     const currentValue = selectCount(getState());
//     if (currentValue % 2 === 1) {
//         dispatch(incrementByAmount(amount));
//     }
// };